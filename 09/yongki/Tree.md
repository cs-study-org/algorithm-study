# íŠ¸ë¦¬

## ì´ë¡ 

<details>
<summary>íŠ¸ë¦¬ ì¢…ë¥˜</summary>
<br/>

íŠ¸ë¦¬ë€

    ê³„ì¸µì ì¸ ê´€ê³„ë¥¼ ê°€ì§„ ìë£Œì˜ í‘œí˜„ì— ì‚¬ìš©í•˜ëŠ” ìë£Œêµ¬ì¡°ì´ë‹¤.

ì¼ë°˜ íŠ¸ë¦¬ëŠ”

    ë…¸ë“œê°€ ì„ì˜ì˜ ê°œìˆ˜ì˜ ìì‹ì„ ê°€ì§ˆ ìˆ˜ ìˆëŠ” íŠ¸ë¦¬ì´ë‹¤.    

    ë…¸ë“œë§ˆë‹¤ ë§í¬ì˜ ìˆ˜ê°€ ë‹¤ë¥´ê¸° ë•Œë¬¸ì— ë³µì¡í•˜ë‹¤.

ì´ì§„ íŠ¸ë¦¬ëŠ”

    ë…¸ë“œê°€ ìµœëŒ€ 2ê°œì˜ ìì‹ë§Œ ê°€ì§€ë„ë¡ ì œí•œí•œë‹¤.

í¬í™” ì´ì§„ íŠ¸ë¦¬ëŠ”

    ê° ë ˆë²¨ì— ë…¸ë“œê°€ ê½‰ ì°¨ìˆëŠ” ì´ì§„ íŠ¸ë¦¬ì´ë‹¤.

    ë”°ë¼ì„œ ë…¸ë“œì— ìˆœì„œëŒ€ë¡œ ë²ˆí˜¸ë¥¼ ë¶™ì¼ ìˆ˜ ìˆë‹¤.

ì™„ì „ ì´ì§„ íŠ¸ë¦¬ëŠ”

    í¬í™” ì´ì§„ íŠ¸ë¦¬ì™€ ìœ ì‚¬í•˜ì§€ë§Œ, ë§ˆì§€ë§‰ ë ˆë²¨ì˜ ë…¸ë“œëŠ” ë¹„ì–´ìˆì–´ë„ ëœë‹¤.

</details>

<details>
<summary>ì´ì§„ íŠ¸ë¦¬ í‘œí˜„</summary>

### ë°°ì—´ í‘œí˜„

í¬í™” ì´ì§„ íŠ¸ë¦¬ì™€ ì™„ì „ ì´ì§„ íŠ¸ë¦¬ì— ê°€ì¥ ì í•©í•˜ë‹¤.

ë°°ì—´ í•­ëª© ì‚¬ì´ì— ë¹ˆì¹¸ì´ ë°œìƒí•˜ì§€ ì•Šê¸° ë•Œë¬¸ì´ë‹¤.

    ì´ì™€ ë°˜ëŒ€ë¡œ, ê²½ì‚¬ ì´ì§„ íŠ¸ë¦¬ëŠ” ë¹ˆì¹¸ì´ ë§ì´ ë°œìƒí•œë‹¤.

ì–´ë–¤ ë…¸ë“œì˜ ì¸ë±ìŠ¤ë¥¼ ì•Œë©´ 

    ë¶€ëª¨ ì¸ë±ìŠ¤ =             i / 2

    ì™¼ìª½ ìì‹ ì¸ë±ìŠ¤ =        2i

    ì˜¤ë¥¸ìª½ ìì‹ ì¸ë±ìŠ¤ =      2i + 1  ì•Œ ìˆ˜ ìˆë‹¤.

### ë§í¬ í‘œí˜„

ë‘ê°œì˜ ë§í¬ë¥¼ ë‹´ëŠ” êµ¬ì¡°ì²´ë¥¼ í™œìš©í•œë‹¤.

```js
var TreeNode = function (value, left, right) {
  this.value;
  this.left;
  this.right;
}
```
> ì´ë²ˆ ì£¼ì œì˜ êµ¬í˜„ ë¬¸ì œëŠ” ëª¨ë‘ ë§í¬ í‘œí˜„ìœ¼ë¡œ ì§„í–‰í•œë‹¤.

</details>

<details>
<summary>ì‚¬ìš© ì‚¬ë¡€</summary>
<br/>

Node.jsì˜ íŒ¨í‚¤ì§€ ì˜ì¡´ì„±ì´ ì§ê´€ì ìœ¼ë¡œ ë– ì˜¬ëë‹¤.

Node.jsëŠ” íŒ¨í‚¤ì§€ê°€ ì–´ë”¨ëŠ”ì§€ ì•Œì§€ ëª»í•´ íŒ¨í‚¤ì§€ì˜ ëª¨ë“ˆì´ í•„ìš” í•  ë•Œ, ë§¤ë²ˆ `readdir` ì‹œìŠ¤í…œ ì½œì„ ë‚ ë ¤ íƒìƒ‰í•œë‹¤.

ì´ë•Œ ì•„ë˜ì™€ ê°™ì€ íƒìƒ‰ ì•Œê³ ë¦¬ì¦˜ì„ ì‚¬ìš©í•œë‹¤.

<div align="center"><img width="60%" src="assets/node-module-search-alg.jpg"/></div>

`node_modules í´ë”`ì—ëŠ” ì˜ì¡´ì„±ì´ ë™ê¸°í™”ëœ íŒ¨í‚¤ì§€ë§Œ ì„¤ì¹˜ëœë‹¤.

ì¦‰, ê°™ì€ ì´ë¦„ì¸ íŒ¨í‚¤ì§€ì˜ ë‹¤ë¥¸ ë²„ì „ì˜ ëª¨ë“ˆë“¤ì´ ì„¤ì¹˜ë˜ì§€ ì•ŠëŠ”ë‹¤.

ì–´ë–»ê²Œ ë™ê¸°í™”í–ˆì„ê¹Œ?

ë‹¤ìŒì€ ìµœìƒìœ„ ê²½ë¡œì¸ í”„ë¡œì íŠ¸ì—ì„œ ëª…ì‹œí•œ `package.json`ì´ë‹¤.

```json
  "dependencies": {        
    "body-parser": "^1.19.0",
    ...
  }
```

ì‹¤ì œ ì„¤ì¹˜ëŠ” ë‹¤ë¥¸ íŒ¨í‚¤ì§€ì˜ ë²„ì „ì´ ì„¤ì¹˜ë˜ì—ˆë‹¤.

`body-parser`ë¥¼ ì˜ì¡´í•˜ëŠ” `express`íŒ¨í‚¤ì§€ì˜ ë²„ì „ì´ ë” major í•˜ê¸° ë•Œë¬¸ì´ë‹¤.

```shell
â”œâ”€â”¬ body-parser@1.19.2
â”œâ”€â”¬ express@4.17.3
â”‚ â”œâ”€â”€ body-parser@1.19.2 deduped
```

ì–´ë–¤ íŒ¨í‚¤ì§€ê°€ ì˜ì¡´í•˜ëŠ” íŒ¨í‚¤ì§€ëŠ” ê° íŒ¨í‚¤ì§€ì˜ `package.json`ì— ëª…ì‹œëœë‹¤.

íŒ¨í‚¤ì§€ ê°„ì˜ ì˜ì¡´ì„±ì„ `package.json`ì— ëª…ì‹œëœ íŒ¨í‚¤ì§€ë¥¼ íŠ¸ë¦¬ì˜ ë…¸ë“œë¡œ ìƒê°í•˜ì—¬ ì˜ì¡´ì„± íŠ¸ë¦¬ê°€ êµ¬ì„±ë˜ì—ˆë‹¤ê³  ìƒê°í•˜ì.

<div align="center"><img width="100%" src="assets/node-module-tree.drawio.svg"/></div>

í˜„ì¬ ì„¤ì¹˜ëœ `body-parser`ì™€ ë‹¤ë¥¸ ë²„ì „ì„ ì„¤ì¹˜í•œë‹¤ê³  í–ˆì„ ë•Œ, 

íŠ¸ë¦¬ì—ì„œ `body-parser`ë…¸ë“œë¥¼ ì°¾ì•„ ë²„ì „ì„ í™•ì¸í•œë’¤, ë™ê¸°í™”ë¥¼ ë§ì¶˜ë‹¤.

</details>

## êµ¬í˜„

<details>
<br/>

<div align="center"><img width="60%" src="assets/tree-example.jpg"/></div>

í•„ìˆ˜ë©”ì†Œë“œì™€ ë¹…ì˜¤ëŠ” ë‹¤ìŒê³¼ ê°™ë‹¤.

- time(worst)ëŠ” ì´ì§„ íŠ¸ë¦¬ì— ì ìš©ë˜ê³ ,

- time(avg)ëŠ” ì™„ì „ ì´ì§„ íŠ¸ë¦¬ì— ì ìš©ëœë‹¤.

|             |  `insert`  |  `delete`  | `_getMinValueAtRightSubtree` |
| :---------: | :--------: | :--------: | :--------------------------: |
| time(worst) |   `O(n)`   |   `O(n)`   |            `O(n)`            |
|  time(avg)  | `O(log n)` | `O(log n)` |            `O(n)`            |
|    space    |   `O(1)`   |   `O(1)`   |            `O(1)`            |

`delete` ë©”ì†Œë“œ ê°™ì€ ê²½ìš° ê¹Œë‹¤ë¡œìš´ ê²½ìš°ê°€ ìˆë‹¤.

ì˜ˆë¡œ, 90ì„ ì‚­ì œí–ˆì„ ë•Œ, í•´ë‹¹ ë…¸ë“œë¡œ ì˜¬ë¼ì˜¬ ê³„ìŠ¹ìë¥¼ ì„ ì •í•´ì•¼í•œë‹¤.

ì´ ë¶€ë¶„ì„ ìš°ì¸¡ ì„œë¸ŒíŠ¸ë¦¬ì—ì„œ ì°¾ëŠ”ë‹¤. (`_getMinValueAtRightSubtree`)

```js
BinarySearchTree.prototype._deleteAtNode = function (node, deleteValue) {
  // +++ node.value === deleteValue
  else {
    ...
    // +++ left, right all exist
    node.value = this._getMinValueAtRightSubtree(node.right);
    node.right = this._deleteAtNode(node.right, node.value);
  }

  return node;
}
```
```js
BinarySearchTree.prototype._getMinValueAtRightSubtree = function (node) {
  let min = node.value;

  while (node.left) {
    min = node.left.value;
    node = node.left;
  }

  return min;
}
```

íŠ¸ë¦¬ ìˆœíšŒ ê´€ë ¨ ë©”ì†Œë“œì™€ ë¹…ì˜¤ëŠ” ë‹¤ìŒê³¼ ê°™ë‹¤.

- `n`ì€ íŠ¸ë¦¬ì˜ ëª¨ë“  ë…¸ë“œì˜ ìˆ˜ë¥¼ ì˜ë¯¸í•œë‹¤.
- `L`ì€ íŠ¸ë¦¬ì˜ level ìˆ˜ë¥¼ ì˜ë¯¸í•œë‹¤.

|       | `display` | `inorder` | `preorder` | `postorder` | `levelorder` |
| :---: | :-------: | :-------: | :--------: | :---------: | :----------: |
| time  |  `O(n)`   |  `O(n)`   |   `O(n)`   |   `O(n)`    |    `O(n)`    |
| space |  `O(n)`   |  `O(n)`   |   `O(n)`   |   `O(n)`    |    `O(nL)`    |

</details>

## ì´ì›”ëœ ë¬¸ì œ ë¦¬ìŠ¤íŠ¸

> ì…ë ¥ê°’ìœ¼ë¡œ ì£¼ì–´ì§„ ì´ì§„ íŠ¸ë¦¬ëŠ” ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ê°€ ì•„ë‹ˆë¼ì„œ ë³„ë„ì˜  ì—ë””í„°ì—ì„œ ê·¸ëŒ€ë¡œ êµ¬í˜„í•˜ê¸° ì–´ë ¤ì› ë‹¤.
>
> ë”°ë¼ì„œ, ë³„ë„ì˜ ë¬¸ì œ íŒŒì¼ë¡œ ë¹¼ì§€ ëª»í•˜ê³ , ë¬¸ì œ ì—ë””í„°ì—ì„œ ë°”ë¡œ í•´ê²°í•˜ì˜€ë‹¤.
>
> ë‹¨, ë¬¸ì œì—ì„œ ì‚¬ìš©ë˜ëŠ” ìë£Œêµ¬ì¡°ëŠ” ADTë¥¼ í™œìš©í•˜ì˜€ë‹¤.

**[ì¡°ê±´: DFS í’€ì´]**

ë‘ ë¬¸ì œëŠ” BFSë¡œ ë°–ì— í’€ìˆ˜ ì—†ëŠ” ìœ í˜•ì´ë‹¤.

ë‹¤ìŒ ì˜ˆë¡œ `112ë²ˆ` ë¬¸ì œì˜ ê·¸ë¦¼ì„ ë³´ë©´ DFSì—ì„œ ìŠ¤íƒì„ ì‚¬ìš©í•  ë¿ 

ë„“ì´ ìš°ì„  íƒìƒ‰ì„ í•˜ê¸° ë•Œë¬¸ì— DFSë¼ê³  ë³¼ ìˆ˜ ì—†ë‹¤.

<div align="center"><img width="60%" src="assets/112-dfs&bfs-difference-issue.jpg"/></div>

<details>
<summary>112. Path Sum
  <a href="https://leetcode.com/problems/path-sum/">ğŸ‘Š</a>
</summary>

### ë¬¸ì œ í’€ì´ [`#Iterative BFS`]

```js
/**
 * @param {TreeNode} root
 * @param {number} targetSum
 * @return {boolean}
 * 
 * w as width
 *
 * time:    O(n)
 * space:   O(w)
 */
var hasPathSum = function (root, targetSum) {
  if (!root)
    return false;

  const stack = new Stack();
  stack.push({ 'node': root, 'remainValue': targetSum });

  while (!stack.isEmpty()) {
    const { node, remainValue } = stack.pop();

    if (
      !node.left
      && !node.right
      && node.val === remainValue
    )
      return true;

    if (node.left)
      stack.push({ 'node': node.left, 'remainValue': remainValue - node.val });

    if (node.right)
      stack.push({ 'node': node.right, 'remainValue': remainValue - node.val });
  }
  return false;
};
```

</details>

<details>
<summary>257. Binary Tree Paths
  <a href="https://leetcode.com/problems/binary-tree-paths/">ğŸ‘Š</a>
</summary>

### ë¬¸ì œ í’€ì´ [`#Iterative BFS`]

```js
/**
 * @param {TreeNode} root
 * @return {string[]}
 *  
 * w as width
 * 
 * time:    O(n)
 * space:   O(w)
 */
var binaryTreePaths = function (root) {
  const result = [];

  const stack = new Stack();
  stack.push({ 'node': root, 'path': String(root.val) });

  while (!stack.isEmpty()) {    
    const { node, path } = stack.pop();

    if (
      !node.left
      && !node.right
    )
      result.push(path);

    if (node.left)
      stack.push({
        'node': node.left, 'path': `${path}->${String(node.left.val)}`
      });

    if (node.right)
      stack.push({
        'node': node.right, 'path': `${path}->${String(node.right.val)}`
      });
  }
  return result;
};
```

</details>
<br/>

**[ì¡°ê±´: BFS í’€ì´]**

<details>
<summary>104. Maximum Depth of Binary Tree
  <a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/">ğŸ‘Š</a>
</summary>

### ë¬¸ì œ í’€ì´ 1/2 (`#Recursive BFS`)

ì§ê´€ì ìœ¼ë¡œ ë– ì˜¤ë¥¸ í’€ì´ë‹¤.

í•¨ìˆ˜ë¥¼ ë…¸ë“œì˜ ìì‹ì„ ë°œê²¬í•  ë•Œë§ˆë‹¤ 

ê¹Šì´ë¥¼ 1 ë”í•œ ë§¤ê°œë³€ìˆ˜ì™€ í•¨ê»˜ ì¬ê·€ì  í˜¸ì¶œí•œë‹¤.

ë¦¬í„´ëœ ê°’ë“¤ì—ì„œ ìµœëŒ“ê°’ì´ ê²°ê³¼ê°’ì´ë‹¤.

```js
var getMaxDepth = function(node, level){
  let curDepth = level;
  let left = 1;
  let right = 1;
  
  if(!node)
    return curDepth;
  
  if(node.left)
    left = getMaxDepth(node.left, level + 1);

  if(node.right)
    right = getMaxDepth(node.right, level + 1);  
  
  return Math.max(curDepth, left, right);
}

/**
 * @param {TreeNode} root
 * @return {number}
 * 
 * 
 * time:    O(n)
 * space:   O(w)
 */
var maxDepth = function(root) {
  if(!root)
    return 0;
    
  return getMaxDepth(root, 1);
};
```

### ë¬¸ì œ í’€ì´ 2/2 (`#Iterative BFS`)

```js
/**
 * @param {TreeNode} root
 * @return {number}
 * 
 * time:    O(n)
 * space:   O(w)
 */
var maxDepth = function(root) {
  if(!root)
    return 0;
  
  let result = 1;
  
  const queue = new Queue();
  queue.enQueue({'node': root, 'depth': 1});
  
  while(!queue.isEmpty()){
    const {node, depth} =  queue.Front();        
    
    if(!node)
      continue;
    
    if(!node.left && !node.right)
      result = Math.max(result, depth);
    
    if (node.left)
      queue.enQueue({'node': node.left, 'depth': depth + 1});
    
    if (node.right)
      queue.enQueue({'node': node.right, 'depth': depth + 1});
    
    queue.deQueue();
  }
  
  return result;
};
```
</details>

<details>
<summary>101. Symmetric Tree
  <a href="https://leetcode.com/problems/symmetric-tree/submissions/">ğŸ‘Š</a>
</summary>

### ë¬¸ì œ íšŒê³ 

êµ¬í˜„í•´ë†“ì€ ìˆœíšŒ ë©”ì†Œë“œ ì¤‘ `inorder`ë¥¼ ì¢Œì¸¡, ìš°ì¸¡ ë²„ì „ìœ¼ë¡œ ë³€í˜•í•œ ë’¤,

ê° ìˆœíšŒ ê²°ê³¼ ë¦¬ìŠ¤íŠ¸ë¥¼ ë¹„êµí•˜ë©´ ëœë‹¤ ìƒê°í–ˆë‹¤.

ì´ëŠ” ê³µê°„ ë³µì¡ë„ê°€ ìƒê¸°ê³ ,

`null`ì„ ì²´í¬í•˜ì§€ ëª»í•´ ê° ìˆœíšŒ ê²°ê³¼ëŠ” ë™ì¼í•˜ë˜ ëŒ€ì¹­ì€ ì•„ë‹Œ í…ŒìŠ¤íŠ¸ì¼€ì´ìŠ¤ë¥¼ í†µê³¼í•˜ì§€ ëª»í–ˆë‹¤.

    Input:  [1,2,2,null,3,null,3]
    Output: false

### ë¬¸ì œ í’€ì´ 1/2 [`#Recursive BFS`]

```js
/**
 * @param {TreeNode} root
 * @return {boolean}
 * 
 * time:    O(n)
 * space:   O(w)
 */
var isSymmetric = function(root) {
  if(!root)
    return true;
  
  return isMirror(root.left, root.right);
};

var isMirror = function(nodeA, nodeB){
  if(!nodeA && !nodeB)
    return true;
  
  if(!nodeA || !nodeB)
    return false;
  
  if(nodeA.val != nodeB.val)
    return false;
  
  return isMirror(nodeA.right, nodeB.left)
      && isMirror(nodeA.left, nodeB.right);
}
```

### ë¬¸ì œ í’€ì´ 2/2 [`#Iterative BFS`]

```js
/**
 * @param {TreeNode} root
 * @return {boolean} 
 * 
 * time:    O(n)
 * space:   O(w)
 */
var isSymmetric = function(root) {
  if(!root)
    return true;
  
  const queue = new Queue();
  
  queue.enQueue(root.left);
  queue.enQueue(root.right);
  
  while(!queue.isEmpty()){    
    const nodeA = queue.poll();
    const nodeB = queue.poll();
    
    if(!nodeA && !nodeB)
      continue;
    
    if(!nodeA || !nodeB)
      return false;
    
    if(nodeA.val !== nodeB.val)
      return false;
        
    queue.enQueue(nodeA.left);
    queue.enQueue(nodeB.right);

    queue.enQueue(nodeA.right);
    queue.enQueue(nodeB.left);     
  }
  
  return true;
};
```
</details>

## ë¬¸ì œ ë¦¬ìŠ¤íŠ¸

<details>
<summary>99. Recover Binary Search Tree
  <a href="https://leetcode.com/problems/recover-binary-search-tree/">ğŸ‘Š</a>
</summary>

### ë¬¸ì œ íšŒê³ 

ë§í¬ í‘œí˜„ì—ì„œ swapì„ í•´ì•¼í•´ì„œ ì ‘ê·¼í•˜ê¸° ì–´ë ¤ì› ë˜ ë¬¸ì œì˜€ë‹¤.

### ë¬¸ì œ í’€ì´ 1/3 [`#Recursive Inorder` `#BFS` `#space O(n)`]

ì°¸ê³ í•œ ì½”ë“œëŠ” inorderì˜ ìˆœíšŒë¥¼ í™œìš©í•˜ì˜€ë‹¤.

ì •ìƒì ì¸ ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ëŠ” inorderì‹œ, ì˜¤ë¦„ì°¨ìˆœì´ ìœ ì§€ëœë‹¤.

ë”°ë¼ì„œ ì˜¤ë¦„ì°¨ìˆœ ìœ ì§€ê°€ ë˜ì§€ ì•Šì€ ë…¸ë“œë“¤ì„ ê¸°ì–µí•˜ë©´ëœë‹¤.

íŠ¸ë¦¬ë¥¼ ìˆœíšŒí•  ë•Œë§ˆë‹¤ 

ì´ì „ ìˆœíšŒí•œ ë…¸ë“œë¥¼ ê¸°ì–µí•˜ë©´ì„œ swap ëŒ€ìƒì´ ë˜ëŠ” ë…¸ë“œAì™€ ë…¸ë“œBë¥¼ ë„ì¶œí•œë‹¤.

<table>
  <tr>
    <td>
      <div align="center">
        <img src="assets/99-recursive-solution.png"/>
      </div>
    </td>
    <td>
<p>

```js
/**
 * @param {TreeNode} root
 * @return {void} Do not return anything, modify root in-place instead.
 *
 * time:    O(n)
 * space:   O(w)
 */
var recoverTree = function(root) {  
  let nodeA = null;
  let nodeB = null;
  let prevNode = null;
  
  function swap(nodeA, nodeB){
    let temp = nodeA.val;
    nodeA.val = nodeB.val;
    nodeB.val = temp;
  }
  
  function inorderWithMemory(node) {
    if(!node)
      return;    
    
    inorderWithMemory(node.left);
    
    if(!nodeA && (!prevNode || prevNode.val >= node.val))
      nodeA = prevNode;
    
    if(nodeA && prevNode.val >= node.val)
      nodeB = node;    
    
    prevNode = node;    
    
    inorderWithMemory(node.right);     
  }
  
  inorderWithMemory(root);  
  swap(nodeA, nodeB);
};
```
</p>
    </td>
  </tr>
</table>


### ë¬¸ì œ í’€ì´ 2/3 [`#Iterative Inorder` `#DFS` `#space O(n)`]

<table>
  <tr>
    <td>
      <div align="center">
        <img src="assets/99-iterative-solution.png"/>
      </div>
    </td>
    <td>
<p>

```js
/**
 * @param {TreeNode} root
 * @return {void} Do not return anything, modify root in-place instead.
 *
 * time:    O(n)
 * space:   O(h)
 */
var recoverTree = function(root) {    
  let nodeA = null;
  let nodeB = null;
  
  function swap(nodeA, nodeB){
    let temp = nodeA.val;
    nodeA.val = nodeB.val;
    nodeB.val = temp;
  }
  
  let cur = root;
  let prev = null;
  const stack = new Stack();
  
  while(!stack.isEmpty() || cur){
    if(cur){          // +++ visit cur's left subtree
      stack.push(cur);
      cur = cur.left;
    }else{            // +++ cur's left subtree is done
      cur = stack.pop();
      
      if(prev && cur.val <= prev.val){
        if(!nodeA)
          nodeA = prev;
        
        nodeB = cur;
      }
      
      // +++ visit cur's right subtree
      prev = cur;
      cur = cur.right;
    }
  }
  
  swap(nodeA, nodeB);
};
```
</p>
    </td>
  </tr>
</table>

### ë¬¸ì œ í’€ì´ 3/3 [`#Non-recursive Inorder` `#space O(1)`]

`Non-recursive Inorder`ì€  `Morris traversal` ì•Œê³ ë¦¬ì¦˜ì´ë¼ê³  í•œë‹¤.

ê°„ë‹¨íˆ ì„¤ëª…í•˜ë©´,

    1. curë¥¼ rootë¡œ ì´ˆê¸°í™”í•œë‹¤.
    2. curì´ nullì´ ì•„ë‹ˆë©´, curì— ì™¼ìª½ ìì‹ì´ ìˆëŠ”ì§€ íƒìƒ‰í•œë‹¤.
    3. curì— ì™¼ìª½ ìì‹ì´ ì—†ìœ¼ë©´ curì˜ ì˜¤ë¥¸ìª½ ë…¸ë“œë¥¼ ê°€ë¦¬í‚¤ë„ë¡ ë°”ê¾¼ë‹¤.
       ë˜ëŠ”,  curë¥¼ curì˜ ì™¼ìª½ í•˜ìœ„ íŠ¸ë¦¬ì—ì„œ ê°€ì¥ í° ë…¸ë“œë¡œ ë°”ê¾¼ë‹¤.    

<table>
  <tr>
    <td>
      <div align="center">
        <img src="assets/99-non-recursive-solution.png"/>
      </div>
    </td>
    <td>
<p>

```js
/**
 * @param {TreeNode} root
 * @return {void} Do not return anything, modify root in-place instead.
 * 
 * time:    O(n)
 * space:   O(1)
 */
var recoverTree = function(root) {
  let nodeA = null;
  let nodeB = null;
  
  function swap(nodeA, nodeB){
    let temp = nodeA.val;
    nodeA.val = nodeB.val;
    nodeB.val = temp;
  }
    
  let pred = null;
  let prev = null;  
  let cur = root;
  
  while(cur){
    // +++ Recover
    if(prev && cur.val <= prev.val){
      if(!nodeA)
        nodeA = prev;
      
      nodeB = cur;
    }
        
    if(!cur.left){
      prev = cur;
      cur = cur.right;
    }else{
      // +++ Find pred in left subtree
      pred = cur.left;
      
      while(pred.right && pred.right != cur)
        pred = pred.right;
      
      // +++ Make cur as right child of its prev
      if(pred.right != cur){
        pred.right = cur;
        cur = cur.left;
      }     
      // +++ Fix right child of prev
      else{        
        prev.right = null;
        prev = cur;
        cur = cur.right;
      }            
    }
  }
  
  swap(nodeA, nodeB);
};
```
</p>
  </tr>
</table>

</details>

<details> 
<summary>222. Count Complete Tree Nodes
  <a href="https://leetcode.com/problems/count-complete-tree-nodes/">ğŸ‘Š</a>
</summary>

### ë¬¸ì œ íšŒê³ 

ì²˜ìŒ ì ‘ê·¼ ë°©ë²•ì€ BFSí•˜ëŠ” ê²ƒì´ì—ˆë‹¤.

ë‹¨, ì‹œê°„ë³µì¡ë„ê°€ `O(n)`ì´ ë‚˜ì˜¨ë‹¤.

ë¬¸ì œê°€ `medium`ì¸ ì´ìœ ëŠ” ì´ ì‹œê°„ë³µì¡ë„ë¥¼ `O(n)`ë³´ë‹¤ ì ê²Œ ë‚˜ì˜¤ê²Œ í•˜ëŠ” ê²ƒì´ë‹¤.

### ë¬¸ì œ í’€ì´ 1/2 [ğŸ¤” `#time O(log nÂ²)` `#Recursive`]

<table>
  <tr>
    <td>
      <img src="assets/222-time-reduce-solution.png"/>
    </td>
    <td>
<p>

```js
/**
 * @param {TreeNode} root
 * @return {number}
 *
 * time:  O(log nÂ²)
 *        â†’ recursive   O(log n)
 *        â†’ getHeight   O(log n) 
 * space: O(n)
 */
var countNodes = function(root) {    
  if(!root)
    return 0;  
    
  const leftHeight = getLeftHeight(root);
  const rightHeight = getRightHeight(root); 

  if(leftHeight === rightHeight)
    return (1 << leftHeight) - 1;
    
  return countNodes(root.left) + countNodes(root.right) + 1;
};

/**
 * @param {TreeNode} root
 * @return {number}
 *
 * time:  O(log n)
 * space: O(1)
 */
var getLeftHeight = function(node) {
  return node ? getLeftHeight(node.left) + 1 : 0;
};

var getRightHeight = function(node) {
  return node ? getRightHeight(node.right) + 1 : 0;
};

```
</p>
    </td>
  </tr>
</table>

### ë¬¸ì œ í’€ì´ 2/2 [`#time O(log nÂ²)` `#Iterative`]

<table>
  <tr>
    <td>      
    </td>
    <td>
<p>

```js
/**
 * @param {TreeNode} root
 * @return {number}
 *
 * time:  O(log nÂ²)
 * space: O(1)
 */
var countNodes = function(root) {  
  if(!root)
    return 0;
    
  let nodes = 0;  
  
  while(root){         
    const leftHeight = getHeight(root.left);
    const rightHeight = getHeight(root.right); 
    
    if(leftHeight === rightHeight){
      nodes += (1 << leftHeight);
      root = root.right;
    }else{
      nodes += (1 << leftHeight) - 1;
      root = root.left;
    }    
        
    console.log(leftHeight, rightHeight);
    console.log("NODES:", nodes);
  }
  
  return nodes;
};

/**
 * @param {TreeNode} root
 * @return {number}
 *
 * time:  O(log n)
 * space: O(1)
 */
var getHeight = function(root) {
  return root ? getHeight(root.left) + 1 : 0;
};
```
</p>
    </td>
  </tr>
</table>
</details>

<hr/>

## ì°¸ê³  ë¬¸í—Œ

<details>
<summary>ìë£Œêµ¬ì¡° ì´ë¡  ë° êµ¬í˜„</summary>
<br/>

[íŠ¸ë¦¬ ì´ë¡ ](https://namu.wiki/w/íŠ¸ë¦¬(ê·¸ë˜í”„)#s-4.1.1) â” *ë‚˜ë¬´ìœ„í‚¤*

[Node.jsì˜ ëª¨ë“ˆ ê²€ìƒ‰ ì•Œê³ ë¦¬ì¦˜ ì˜ˆì‹œ ì‚¬ì§„](https://www.youtube.com/watch?v=EncMFNfuBw0&list=PLYpU5pCXtxyhLiu0YoBeQq_SSQg8BA2-C&index=5&ab_channel=ì˜¨ë¼ì¸ì½”ë”©ìŠ¤ì¿¨ì½”ë“œì‡) â” *ì½”ë“œì‡*

[`package-lock.json` ì—­í• ](https://junwoo45.github.io/2019-10-02-package-lock/) â” *ë°•ì¤€ìš° ë¸”ë¡œê·¸*

[ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ `delete ë©”ì†Œë“œ` êµ¬í˜„](https://www.geeksforgeeks.org/binary-search-tree-set-2-delete/) â” *GeeksforGeeks*

[ì´ì§„ íŠ¸ë¦¬ DFS vs BFS](https://www.geeksforgeeks.org/bfs-vs-dfs-binary-tree/) â” *GeeksforGeeks*

[What is Morris traversal?](https://www.educative.io/edpresso/what-is-morris-traversal) â” *educative*
</details>

<details>
<summary>í’€ì´ ì°¸ê³ </summary>
<br/>

[Simple Solution at 112. Path Sum](https://leetcode.com/problems/path-sum/discuss/36581/My-Python-iterative-DFS-solution) â” *LeetCode*

[Simple Solution at 101. Symmetric Tree](https://leetcode.com/problems/symmetric-tree/discuss/433170/isMirror-DFS-(Recursion-OneTwo-Stacks)-%2B-BFS-(Queue)-Solution-in-Java) â” *LeetCode*

[Simple Solution at 99. Recover Binary Search Tree](https://leetcode.com/problems/recover-binary-search-tree/discuss/32562/Share-my-solutions-and-detailed-explanation-with-recursiveiterative-in-order-traversal-and-Morris-traversal) â” *LeetCode*

[Simple Solution at 222. Count Complete Tree Nodes](https://leetcode.com/problems/count-complete-tree-nodes/discuss/61958/Concise-Java-solutions-O(log(n)2)) â” *LeetCode*

[Simple Solution at 222. Count Complete Tree Nodes](https://www.youtube.com/watch?v=4wPlA_InnGY&ab_channel=CodingBeats) â” *CodingBeats*
</details>
