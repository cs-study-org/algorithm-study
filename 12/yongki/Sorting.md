# 정렬

## 이론

정렬 알고리즘을 평가하는 효율성의 기준은

    a. 비교 연산의 횟수와

    b. 이동 연산의 횟수이다.

비교 연산의 횟수와 이동 연산의 횟수는 서로 비례하지 않는다.

    cf. 비교 연산의 횟수는 > 이동 연산의 횟수

        그 반대도 가능하다.

> 🤔 시간복잡도 계산에 적용

<details>
<summary>안정 정렬</summary>

    중복된 값을 입력 순서와 동일하게 정렬한다.

빅오는 다음과 같다.

|       |  삽입   |  버블   |     병합     | 퀵 정렬(not in-place) |
| :---: | :-----: | :-----: | :----------: | :-------------------: |
| 최선  | `O(n)`  | `O(n)`  | `O(n log n)` |     `O(n log n)`      |
| 평균  | `O(n²)` | `O(n²)` | `O(n log n)` |     `O(n log n)`      |
| 최악  | `O(n²)` | `O(n²)` | `O(n log n)` |        `O(n²)`        |
| 공간  | `O(1)`  |    -    |      -       |        `O(n)`         |

### 삽입 정렬

    왼쪽에서 오른쪽으로 가면서 각 요소들을 왼쪽 요소들과 비교하여 알맞은 자리에 삽입한다.

장점은

    이미 정렬되어 있는 경우

    in-place 방법의 알고리즘이다.

단점은

    정렬이 되어있지 않는 경우이다.
    
    즉, 데이터가 많을 수록 적합하지 않다.

### 퀵 정렬 (not in-place)

장점은

    stable하다.

단점은

    in place 방법이 아니다.

</details>

<details>
<summary>불안정 정렬</summary>

    중복된 값을 입력 순서와 동일하지 않게 정렬한다.

빅오는 다음과 같다.

|       |  선택   | 퀵(in-place) |      힙      |
| :---: | :-----: | :----------: | :----------: |
| 최선  | `O(n²)` | `O(n log n)` | `O(n log n)` |
| 평균  | `O(n²)` | `O(n log n)` | `O(n log n)` |
| 최악  | `O(n²)` |   `O(n²)`    | `O(n log n)` |
| 공간  | `O(n)`  |  `O(log n)`  |    `O(n)`    |

> 🤔 퀵 정렬 공간 복잡도 차이 다이어그램

### 선택 정렬

**in-place[^in-place] 하지 않은 방법**

    1. 왼쪽 리스트에는 정렬이 완료된 요소들이, 오른쪽 리스트에는 정렬되지 않은 요소들이 들어 있다.

        초기 상태에 왼쪽 리스트는 비어 있다.

    2. 오른쪽 리스트에서 최소값을 선택하여 왼쪽 리스트로 이동하는 작업을 되풀이 한다.

[^in-place]: 추가 메모리를 요구하지 않는 방법이다.

**in-place한 방법**

    1. 리스트에서 최소값을 선택한 다음, 이 최소값을 리스트의 첫번째 요소와 교환한다.

    2. 첫번째 요소를 제외한 나머지 요소들 중에서 위 작업을 되풀이 한다.

특징으로는

    매 작업마다 n번째 데이터의 위치가 정해진다.

    버블 정렬과 비교하면 

    버블 정렬은 매 작업마다 맨 마지막 데이터의 위치가 정해진다.

장점은

    in place 방법을 사용할 때이다.

단점은

    이미 정렬되어 있는 경우에도 매번 최소값을 찾는다.

### 퀵 정렬 (in-place)

장점은

    한번 결정된 피벗들이 추후 연산에서 제외된다.

단점은

    🤔 불균형 분할일 경우 정렬된 리스트에 대해서 수행시간이 더 많이 걸린다.

어떻게 시간복잡도 `n²`이 나오는가?

    ...

어떻게 분할하는가?

    1. low와 high를 왼쪽과 오른쪽에서 출발시켜서 부적절한 데이터를 만나게 되면 교환하고 
    
        아니면 계속 진행하다가 서로 엇갈리게 되면 멈춰서 피봇을 중앙으로 이동시킨다.

    2. 그러면 피봇을 기준으로 2개의 리스트로 나누어지게 된다.

    3. 각각의 부분 리스트를 다시 퀵정렬한다.

### 힙 정렬

> 지난 10주차 힙 주제의 [md 링크](https://github.com/cs-study-org/algorithm-study/tree/main/10/yongki/Heap.md)를 첨부한다.

</details>

<hr/>

## 참고 문헌

[정렬 알고리즘 시간 복잡도](https://velog.io/@good159897/안정-정렬-VS-불안정-정렬-파이썬-알고리즘-인터뷰) ━ *velog*