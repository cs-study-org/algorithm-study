# 정렬

## 이론

정렬 알고리즘을 평가하는 효율성의 기준은

    a. 비교 연산의 횟수와

    b. 이동 연산의 횟수이다.

비교 연산의 횟수와 이동 연산의 횟수는 서로 비례하지 않는다.

    cf. 비교 연산의 횟수는 > 이동 연산의 횟수

        그 반대도 가능하다.

<details>
<summary>안정 정렬</summary>

    중복된 값을 입력 순서와 동일하게 정렬한다.

시간복잡도는 다음과 같다.

|       |  삽입   |  버블   |     병합     |
| :---: | :-----: | :-----: | :----------: |
| 최선  | `O(n)`  | `O(n)`  | `O(n log n)` |
| 평균  | `O(n²)` | `O(n²)` | `O(n log n)` |
| 최악  | `O(n²)` | `O(n²)` | `O(n log n)` |

### 퀵 정렬 (not in-place)

</details>

<details>
<summary>불안정 정렬</summary>

    중복된 값을 입력 순서와 동일하지 않게 정렬한다.

시간복잡도는 다음과 같다.

|       |  선택   | 퀵(in-place) |      힙      |
| :---: | :-----: | :----------: | :----------: |
| 최선  | `O(n²)` | `O(n log n)` | `O(n log n)` |
| 평균  | `O(n²)` | `O(n log n)` | `O(n log n)` |
| 최악  | `O(n²)` |   `O(n²)`    | `O(n log n)` |

### 선택 정렬

**in-place[^in-place] 하지 않은 방법**

    1. 왼쪽 리스트에는 정렬이 완료된 숫자들이, 오른쪽 리스트에는 정렬되지 않은 숫자들이 들어 있다.

        초기 상태에 왼쪽 리스트는 비어 있다.

    2. 오른쪽 리스트에서 가장 작은 숫자를 선택하여 왼쪽 리스트로 이동하는 작업을 되풀이 한다.

[^in-place]: 추가 메모리를 요구하지 않는 방법이다.

**in-place한 방법**

    1. 배열에서 최소값을 발견한 다음, 이 최소값을 배열의 첫번째 요소와 교환한다.

    2. 첫번째 요소를 제외한 나머지 요소들 중에서 위 작업을 되풀이 한다.

### 퀵 정렬 (in-place)

장점은

    한번 결정된 피벗들이 추후 연산에서 제외된다.

단점은

    🤔 불균형 분할일 경우 정렬된 리스트에 대해서 수행시간이 더 많이 걸린다.

어떻게 분할하는가?

    1. low와 high를 왼쪽과 오른쪽에서 출발시켜서 부적절한 데이터를 만나게 되면 교환하고 
    
        아니면 계속 진행하다가 서로 엇갈리게 되면 멈춰서 피봇을 중앙으로 이동시킨다.

    2. 그러면 피봇을 기준으로 2개의 리스트로 나누어지게 된다.

    3. 각각의 부분 리스트를 다시 퀵정렬한다.

어떻게 시간복잡도 `n²`이 나오는가?

    ...

</details>

<hr/>

## 참고 문헌

[정렬 알고리즘 시간 복잡도](https://velog.io/@good159897/안정-정렬-VS-불안정-정렬-파이썬-알고리즘-인터뷰) ━ *velog*