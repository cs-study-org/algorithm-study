# 정렬

## 이론

정렬 알고리즘을 평가하는 효율성의 기준은

    a. 비교 연산의 횟수와

    b. 이동 연산의 횟수이다.

비교 연산의 횟수와 이동 연산의 횟수는 서로 비례하지 않는다.

    cf. 비교 연산의 횟수는 > 이동 연산의 횟수

        그 반대도 가능하다.

<details>
<summary>안정 정렬</summary>

    중복된 값을 입력 순서와 동일하게 정렬한다.

시간복잡도는 다음과 같다.


|       |  삽입   |  버블   |     병합     |
| :---: | :-----: | :-----: | :----------: |
| 최선  | `O(n)`  | `O(n)`  | `O(n log n)` |
| 평균  | `O(n²)` | `O(n²)` | `O(n log n)` |
| 최악  | `O(n²)` | `O(n²)` | `O(n log n)` |

</details>

<details>
<summary>불안정 정렬</summary>

    중복된 값을 입력 순서와 동일하지 않게 정렬한다.

시간복잡도는 다음과 같다.

|       |  선택   |      퀵      |      힙      |
| :---: | :-----: | :----------: | :----------: |
| 최선  | `O(n²)` | `O(n log n)` | `O(n log n)` |
| 평균  | `O(n²)` | `O(n log n)` | `O(n log n)` |
| 최악  | `O(n²)` |   `O(n²)`    | `O(n log n)` |

**선택 정렬**

왼쪽 리스트에는 정렬이 완료된 숫자들이,

    초기 상태에 왼쪽 리스트는 비어 있다.

오른쪽 리스트에는 정렬되지 않은 숫자들이 들어 있다.

오른쪽 리스트에서 가장 작은 숫자를 선택하여 왼쪽 리스트로 이동하는 작업을 되풀이 한다.

단, 추가 메모리를 요구하지 않는 `제자리 정렬(in-place sorting)` 방법을 사용하여 

    배열에서 최소값을 발견한 다음, 이 최소값을 배열의 첫번째 요소와 교환한다.

    다음에는 첫번째 요소를 제외한 나머지 요소들 중에서 위 작업을 되풀이 한다.

</details>

<hr/>

## 참고 문헌

[정렬 알고리즘 시간 복잡도](https://velog.io/@good159897/안정-정렬-VS-불안정-정렬-파이썬-알고리즘-인터뷰) ━ *velog*