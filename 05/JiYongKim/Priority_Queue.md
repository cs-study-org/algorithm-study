# 우선순위 큐(Priority Queue) 개념 정리

<br>



## **우선순위 큐란?**
![스크린샷 2022-02-20 오후 11.08.41.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ee9b5953-9763-403d-aed3-c9ab8bd855b4/스크린샷_2022-02-20_오후_11.08.41.png)

<br>

- 일반적인 큐(Queue)는 First in-First Out 구조로 어떤 부가적인 조건 없이 먼저 들어온 데이터가 먼저 나가는 구조이다.

<br>

**하지만,**

**우선순위 큐(Priority Queue)는 들어간 순서에 상관없이** **우선순위가 높은 데이터가 먼저 나오는 자료구조** 를 말한다.

<br>

## 우선순위 큐의 특징

- 우선순위 큐는 값을 비교해야하므로 null을 허용하지 않는다.
- 마찬가지로 비교할 수 없는 객체는 큐를 만들 수 없다.
- 내부구조는 이진트리 힙으로 구성되어 있다
- 내부구조가 **힙으로 구성되어 있기에 시간 복잡도는 `O(logn)`** 이다.

<br>

## **우선순위 큐의 이용 사례**

- 시뮬레이션 시스템
- 네트워크 트래픽 제어
- 운영 체제에서의 작업 스케쥴링
- 수치 해석적인 계산

<br>

## **우선순위 큐의 구현 방식**

- 배열을 통한 구현
    - 단점
        - 우선순위가 중간인 것이 들어가야하는 삽입 과정에서는 뒤의 데이터까지 인덱스를 모두 한 칸씩 뒤로 밀어야 하는 오버헤드가 존재
        - 최악의 경우 삽입해야 하는 위치를 찾기 위해 모든 인덱스를 탐색해야 한다.
            
            ⇒  이 때의 시간 복잡도는 자료가 n개라고 할 때 O(n) 이 된다. 
            
            ⇒  배열로 구현 시 시간 복잡도 : 삭제는 O(1),  삽입은 O(n)
            
            <br>

- 연결리스트를 통한 구현
    - 단점
    - 연결리스트 또한 삽입의 과정 또한 배열과 마찬가지로 그 위치를 찾아야 한다.
        
        ⇒ 최악의 경우 맨 끝 위치까지 가게 된다. 
        
        ⇒ 연결리스트로 구현 시 시간 복잡도 :  삭제는 O(1), 삽입은 O(n)
        
        <br>

- 힙을 통한 구현
    - 힙의 경우 삭제나 삽입 과정에서 모두 부모와 자식 간의 비교만 계속 이루어진다.
    - 이진 트리의 높이가 하나 증가할 때마다 저장 가능한 자료의 갯수는 2배 증가하며, 비교 연산 횟수는 1회 증가합니다.
        
        ⇒ 즉 삭제나 삽입 모두 최악의 경우에는 O(logn) 의 시간 복잡도를 가진다.
        
        ⇒  힙으로 구현 시 시간 복잡도 : 삭제는 O(logn), 삽입은 O(logn)
        
    
    <br>
    
    결론)

    이처럼 배열이나 연결 리스트가 삭제에서는 시간 복잡도의 우위를 점할지라도, 삽입의 시간 복잡도가 힙 기반이 월등하기 때문에, 편차가 심한 배열과 연결리스트보다는 **힙**으로 구현하는 것이다.
    
<br>

## **힙(heap) 이란?**

정의 : 완전 이진 트리의 일종으로 우선순위 큐를 위하여 만들어진 자료구조이다.

<br>

## **힙(heap)의 특징**

- 여러 개의 값들 중에서 최댓값이나 최솟값을 빠르게 찾아내도록 만들어진 자료구조이다.
- 힙은 일종의 반정렬 상태(느슨한 정렬 상태) 를 유지한다.
    - 큰 값이 상위 레벨에 있고 작은 값이 하위 레벨에 있다
    - 간단히 말하면 부모 노드의 키 값이 자식 노드의 키 값보다 항상 큰(작은) 이진 트리를 말한다.
- 힙 트리에서는 중복된 값을 허용한다. (이진 탐색 트리에서는 중복된 값을 허용하지 않는다.)

<br>

## **힙(heap)의 종류**

![스크린샷 2022-02-23 오후 2.41.57.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/99ebf4ce-5e8e-417c-85a9-d367aa72491a/스크린샷_2022-02-23_오후_2.41.57.png)

- 최대 힙(max heap)
    - 부모 노드의 키 값이 자식 노드의 키 값보다 크거나 같은 완전 이진 트리
    - key(부모 노드) >= key(자식 노드)
- 최소 힙(min heap)
    - 부모 노드의 키 값이 자식 노드의 키 값보다 작거나 같은 완전 이진 트리
    - key(부모 노드) <= key(자식 노드)

<br>

## **힙(heap) 구현**

![스크린샷 2022-02-23 오후 2.43.37.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2b99188f-fdc9-4a85-be9e-f67f65dbf4da/스크린샷_2022-02-23_오후_2.43.37.png)

- 힙을 저장하는 표준적인 자료구조는 배열 이다.
- 구현을 쉽게 하기 위하여 배열의 첫 번째 인덱스인 0은 사용되지 않는다.
- 특정 위치의 노드 번호(인덱스)는 새로운 노드가 추가되어도 변하지 않는다.
    - 예를 들어 루트 노드의 오른쪽 노드의 번호는 항상 3이다.
- 힙에서의 부모 노드와 자식 노드의 관계
    - 왼쪽 자식의 인덱스 = (부모의 인덱스) * 2
    - 오른쪽 자식의 인덱스 = (부모의 인덱스) * 2 + 1
    - 부모의 인덱스 = (자식의 인덱스) / 2

## **힙(heap)의 삽입**
<details>
    <summary>힙의 삽입</summary>

1. 힙에 새로운 요소가 들어오면, 일단 새로운 노드를 힙의 마지막 노드에 이어서 삽입한다.
2. 새로운 노드를 부모 노드들과 교환해서 힙의 성질을 만족시킨다.

예시)

![스크린샷 2022-02-23 오후 2.44.55.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7b1070d6-937b-4a24-8d68-19b1970d4bed/스크린샷_2022-02-23_오후_2.44.55.png)

</details>

<br>

## **힙(heap)의 삭제**

<details>
<summary>힙의 삭제</summary>

1. 최대 힙에서 최댓값은 루트 노드이므로 루트 노드가 삭제된다.
2. 최대 힙(max heap)에서 삭제 연산은 최댓값을 가진 요소를 삭제하는 것이다.
3. 삭제된 루트 노드에는 힙의 마지막 노드를 가져온다.
4. 힙을 재구성한다.

예시)

![스크린샷 2022-02-23 오후 2.46.52.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/bff767b9-18e6-4af2-ab8b-8840420563e3/스크린샷_2022-02-23_오후_2.46.52.png)

</details>

<br>

## 우선순위 큐 시간 복잡도

⇒ (단, 힙(heap)을 이용한 우선순위 큐의 시간복잡도만 해당)

|  | enqueue | dequeue |
| --- | --- | --- |
| 우선순위 큐 | O(logn) | O(logn) |

<br>

- 구현시 이용한 자료구조에 따른 시간 복잡도
    
    <details>
    <summary>시간 복잡도</summary>    
    
    (우선순위 큐 구현에 사용하는 자료구조에 따른 시간 복잡도)
    
    ![스크린샷 2022-02-23 오후 3.04.34.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/36003dd7-3a51-4548-bbd8-aa5bd984e748/스크린샷_2022-02-23_오후_3.04.34.png)

    </details>