Amortized Analysis ( 분할 상환 분석 )

**정의** :  **"최악의 경우에 대해 최악의 경우가 발생하도록 연속된 연산을 수행하고,**

<br>

**그때의 한번의 연산에 대한 평균수행시간을 분석하는것"**

>=> 무슨 의미인지 이해하기 어렵다 .. 

<br>

* * *

<br>

### 점근적 분석(**Asymptotic analysis**)과의 비교

**점근적 분석**이란 인풋개수 n에대해 알고리즘의 수행시간을 분석하는 방법을 의미한다.

<br>

분할 상환 분석 또한 점근적 분석과 같은 수행 시간으 분석하는 방법중 하나이다.

<br>

>⇒ 그렇다면 점근적 분석과 분할 상환 분석은 뭐가 다른건가?

<br>

예시)

어떤한 연산이 일어날때,

<br>

그 연산에 대해 **"평소"**에는 연산에 대한 비용이 **1**이다

>⇒ 이것만 생각하면 **O(1)**이라고 볼 수 있다.

<br>

하지만, **정말정말정말 가끔 n번의 연산**이 일어난다.

>⇒ 그럼 점근적 분석을 하면 위의 연산은 O(?)이 될까?

>⇒ **최악의 경우 n번의 연산이 일어나므로 O(n)이다.**

<br>


하지만, 진짜 가끔씩 n번의 연산이 일어나는데 (대부분의 연산이 1인데) O(n)으로 분석하기 너무 **아깝다..**

>⇒ O(1)으로 해도 되는데!! 정말 아깝게 그 가끔의 n번의 연산때문에

>⇒ 점근적 분석에 의해O(n)이 된다.

<br>

이러한 경우때문에 **Amortized Analysis**가 나오게 되었다.

<br>

* * *
<br>

### Array Doubling

(사전 이해)

연산에 맞춰 배열의 크기가 얼마나 사용될지 고정적으로 알기 어렵다.

>⇒ 이를위해 배열을 동적으로 더 큰 크기의 배열을 생성하여 사용하는 방법 중 하나가 더블링 이다.

>⇒ 배열이 꽉 찼을때  

- 배열의 크기를 상수 크기만큼 늘리는 방법
- 배열의 크기를 2배로 늘리는 방법
    
    >⇒ 2가지 방식이 존재하며 더블링이 더 효율적이고 빠르다.
    
    <br>

예)

60명 정원인 방에 사람이 가득 찼을때 더블링 전략을 사용해본다면

<br>

- 60 * 2 = 120 명 정원의 방에 옮긴다
    
    >⇒ 여기서 이전 방에서 다른방으로 사람을 옮기는 비용을 t라 가정한면 ( t 를 transferring cost 라 한다. )
    
    >⇒ 총 60t 의 비용이 들어가게 된다.
    
    ( 만약 n 명일 경우  n * t 비용이 들게 된다. )
    
    <br>

 

- 그렇다면 이전 60명 정원 방도 더블링이 일어났던 상황이라면?
    
    >⇒ 60/2 = 30 명 
    
    >⇒ 30 t의 비용이 추가로 들게 된다.
    
    <br>

- 이러한 방식으로 더블링이 계속 진행되었다면
    
    ⇒ 2t + 4t + 8t + .....
    
- n명의 방에 더블링이 계속 진행되었다면?
    
    >⇒ t*n/2 + t*n/4 + t*n/8+.....
    
    >⇒ 이는 곧 t*n 에 한없이 가까워 지게 된다.
    
     <br>
    

최종)

최종적으로

현재 배열에 더블링이 일어났을 경우 **cost ⇒  t * n**

<br>

현재 더블링이 일어나기 전까지 계속 더블링이 일어났을경우 cost ⇒ t*n


>⇒ 총 2t*n 의 transferring cost 가 들게 된다.

<br>

* * *

<br>

### 분할 상환 분석

분할 상환 분석 기법에는 여러가지 방법이 존재한다

>→ 이 중 “**accounting method”(회계법)** 방식만 설명한다.

<br>

**accounting method 방식이란 ?**

>⇒ 연속적인 연산들이 최악의 경우를 만들 때, 그때의 한번의 연산에 대한 "평균비용"을 구하는 방법

>⇒ 즉 accounting method는 **평균 비용**을 구하기 위한 방식

<br>

**accounting method (회계법)**

>⇒ accounting method는 아래의 식으로 정의된다.

`amortized cost(연산에 대한 평균 비용) = actual cost(실제 비용) + accounting cost(남아있는 비용)`

<br>

- amortized cost (연산에 대한 평균 비용) : 분할 상환 분석 기법중 accounting method 방식을  통해 구하는 평균 비용
    
    >⇒ amortized cost 는 0보다 커야 한다.
    
    <br>

- actual cost (실제 비용) : Stack에 push , pop 과 같은 연산을 진행할때 드는 비용

<br>

- accounting cost :  남아 있는 비용

<br>

### 회계법 예시)

Stack의 push연산의 복잡도 구하기

amortized cost = actual cost + accounting cost

- actual cost
    
    stack의 push의 실제 비용을 1 이라고 가정했을때
    
    - 더블링이 일어나지 않았을 때 실제 비용 : 1
    - 더블링이 일어났을 때 실제 비용 : actual cost = Doubling을 트리거시킨 원소 + Stack A에 있는 원소들을 Stack B로 옮기는 비용 = 1 + t*n
    
    <br>

    최종 actual cost = Doubling을 트리거시킨 원소 + Stack A에 있는 원소들을 Stack B로 옮기는 비용
    
    >⇒ 1 + t* n
    
    <br>

- accounting cost
    
    (accounting cost는 자신이 가지고 있는 비용으로 0이면 1번에 push 조차 할 수 없다.)
    
    즉 accounting cost는 연산 진행을 위해 미리 가지고 있어야할 값을 의미한다.
    
    - accounting cost는 더블링이 일어나던 일어나지 않던 push 수행에 있어 필요한 값을 가지고 있어야 하기 때문에 2t 값을 매번 가지고 있어야 한다.
    
    - 그렇다면 더블링이 일어났을때의 push 연산의 accounting cost는?
        
        >⇒ 더블링이 일어나는데 필요한 transferring  cost = 2t*n 이라고 배웠다.
        
        >⇒ 더블링 이 일어났을때의 accounting cost를 구해보면
        
        >⇒ 2t - t*n
        
    <br>


최종)

amortized cost

- 더블링이 일어나지 않았을때 : 1+2t
- 더블링이 일어났을 때 : (1 + tn) +(2t - tn) = 1 + 2t

<br>

결론)

더블링을 이용해 스택의 push 연산에 대한 복잡도는 amortized O(1+2t) ( t는 무시)

>⇒ 곧  amortized O(1)이 된다.

<br>

스택의 시간복잡도

점근적 분석 : O(n)

분할 상환 분석 : O(1)

<br>

# 참고
[분할 상환 분석 참고 자료](https://zeddios.tistory.com/60)