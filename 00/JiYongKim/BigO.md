# 알리고리즘
## 목차

## 1. 알고리즘 종류

## 2. 알고리즘 성능 분석의 필요성

## 3. 알고리즘 성능 분석 조건

## 4. 시간복잡도란?

## 5. 빅오표기법

## 6. 최선, 평균, 최악

## 7. 공간복잡도란?

* * *
<br>

## 알고리즘 종류

<br>

### **ecursive Call Algorithm (재귀 함수)**

- Maximum value or Minimum value (최대값 또는 최소값 찾기) : 가장 큰 숫자를 기억해가며 진행함
- Euclid (유클리드 알고리즘) : 두 정수의 최대공약수(GCD)를 빠르게 구하기
- Factorial (팩토리얼)
- Fibonacci (피보나치 수열)
- Sum (합계)

<br>

### **Sorting Algorithm (정렬 알고리즘)**

- Selection Sort (선택 정렬)
- Bubble Sort (버블 정렬)
- Quick Sort (퀵 정렬)
- Insertion Sort (삽입 정렬)
- Shell Sort (쉘 정렬)
- Heap Sort (힙 정렬 )
- Merge Sort (병합 정렬)
- Radix Sort (기수 정렬)

<br>

### **Searching Algorithm (탐색 알고리즘)**

- Sequential Search (순차 탐색) = Linear Search (선형탐색)
- Binary Search (이진 탐색)
- Red-Black tree (레드 블랙 트리)

<br>

### **Hash Algorithm (해시 알고리즘)**

- Hash Table (해시 테이블)

<br>

* * *

<br>

## 알고리즘 성능 분석의 필요성

프로그램의 규모는 시간이 지날수록 방대해지며 처리해야하는 데이터의 양 또한 많아진다.

>⇒ 데이터의 양이 많아질수록 알고리즘 간의 효율성 차이는 커질 수 밖에 없다.

<br>

<img width="713" alt="스크린샷 2022-01-18 오후 9 03 42" src="https://user-images.githubusercontent.com/81874493/149946737-a3b75604-5b24-495a-ae9b-a2836fded4e4.png">

>⇒ 위의 표처럼 데이터의 양의 따른 알고리즘 실행 시간 차이가 커진다.

<br>

효율적인 알고리즘이란?

알고리즘이 수행을 시작하여 결과가 도출될 때까지 실행에 걸리는 시간이 짧고 연산하는 컴퓨터 내의 메모리 자원 상대적 덜 사용하는 것이 효율적이라고 할 수 있다.

<br>

* * *

<br>


## 알고리즘 성능 분석 조건

서로 다른 알고리즘을 비교하려면 고려해야할 사항들이 있다.

- 동일한 하드웨어를 사용한 상태에서 실행 시간을 측정해야한다 (실행 환경)
- 동일한 소프트웨어의 환경
    - ex) C언어 와 같은 컴파일 언어를 사용한경우 인터프리터 언어를 사용한 경우보다 실행 속도가 빠르다.

<br>

* * *

<br>

## 시간복잡도란?

시간 복잡도란 특정 알고리즘이 어떤 문제를 해결하는데 걸리는 시간을 의미.

같은 결과를 가져오는 프로그래밍 소스도 어떻게 작성하냐에 따라 걸리는 시간이 달라질 수 있다.

- 시간 복잡도(Time Complexity)는 알고리즘의 절대적인 실행 시간을 나태내는 것이 아닌 알고리즘을 수행하는 데 연산들이 몇번 이루어지는 지를 숫자로 표기한다.
    
    여기서 연산의 종류는 (산술, 대입, 비교, 이동) 을 의미한다.
    
    >⇒ 연산의 실행 횟수는 보편적 상수(Constant)가 아닌 입력한 데이터의 개수를 나타내는 n에 따라 변하게 된다.
    
- 연산의 개수를 입력한 데이터의 개수 n의 함수로 나타낸것을 시간복잡도 함수 라고 말하며, 수식으로 T(n) 이라고 표기한다.

<br>

## 시간복잡도 예시

양의 정수 n을 n 번 더하는 계산을 진행

```java
// case 1
int sum = n * n;

// case 2
int sum = 0;
for(int i=0; i<n ; i++)
	sum +=n;

// case 3
int sum =0;
for(int i =0; i<n; i++)
	for(ing j=0; j<n; j++)
			sum +=1;
```

위의 3가지의 알고리즘의 연산 횟수를 비교해보면 다음과 같이 표로 나타낼 수 있다.

<br>

| 연산종류 | case1 | case2 | case3 |
| --- | --- | --- | --- |
| 대입연산 | 1 | n+1 | n*n+1 |
| 덧셈연산 |  | n | n*n |
| 곱셈연산 | 1 |  |  |
| 나눗셈 연산 |  |  |  |
| 전체 연산 횟수 | 2 | 2n+1 | 2n^2 +1 |

>⇒ 비교연산 생략

하나의 연산이 t 만큼 시간이 필요하다 가정했을때 

- case1 는 2t
- case2 는 (2n+1)t
- case3 는 (2n^2+1)t
    
    >⇒ 만큼의 시간이 필요하게 된다.
    
<br>

**O(1) (Constant)**

입력 데이터의 크기에 상관없이 언제나 일정한 시간이 걸리는 알고리즘을 나타냅니다. 데이터가 얼마나 증가하든 성능에 영향을 거의 미치지 않습니다.

<br>

**O(log₂ n) (Logarithmic)**

입력 데이터의 크기가 커질수록 처리 시간이 로그(log: 지수 함수의 역함수) 만큼 짧아지는 알고리즘입니다. 예를 들어 데이터가 10배가 되면, 처리 시간은 2배가 됩니다. 이진 탐색이 대표적이며, 재귀가 순기능으로 이루어지는 경우도 해당됩니다.

<br>

**O(n) (Linear)**

입력 데이터의 크기에 비례해 처리 시간이 증가하는 알고리즘입니다. 예를 들어 데이터가 10배가 되면, 처리 시간도 10배가 됩니다. 1차원 for문이 있습니다.

<br>

**O(n log₂ n) (Linear-Logarithmic)**

데이터가 많아질수록 처리시간이 로그(log) 배만큼 더 늘어나는 알고리즘입니다. 예를 들어 데이터가 10배가 되면, 처리 시간은 약 20배가 된다. 정렬 알고리즘 중 병합 정렬, 퀵 정렬이 대표적입니다.

<br>

**O(n²) (quadratic)**

데이터가 많아질수록 처리시간이 급수적으로 늘어나는 알고리즘입니다. 예를 들어 데이터가 10배가 되면, 처리 시간은 최대 100배가 됩니다. 이중 루프(n² matrix)가 대표적이며 단, m이 n보다 작을 때는 반드시 O(nm)로 표시하는 것이 바람직합니다.

<br>

**O(2ⁿ) (Exponential)**

데이터량이 많아질수록 처리시간이 기하급수적으로 늘어나는 알고리즘입니다. 대표적으로 피보나치 수열이 있으며, 재귀가 역기능을 할 경우도 해당됩니다.

>※ 여기서 n이란 입력되는 데이터를 의미합니다.

<br>

* * *

<br>

## 빅오 표기법

빅오 표기법(big-oh notation)이란, 시간 복잡두 함수에서 상대적으로 불필요한 연산을 제거하여 알고리즘의 분석을 조금 더 간편하게 할 목적으로 시간 복잡도를 표기하는 방법.

```java
// case 2
int sum =0;
for(int i=0; i<n ; i++)
	sum +=n;
```

>⇒ 여기서의 반복문 사용에 연산횟수

- `int i =0` 대입 연산 1회
- `i<n` n+1 번의 비교 연산
- `sum +=n` n번의 대입 연산

>⇒  2n+2 의 연산이 추가

>⇒ 총 2n +1 + 2n+2 = 4n+3

>⇒ 4n+3의 연산을 필요로 한다

<br>

하지만 중요한것은 정확한 연산의 개수가 아닌 알고리즘의 일반적 증가 추세가 필요.

수식에 포함된 n 이 커지게 되면 2n+1 함수와 4n+3 함수의 차이는 미미해진다.

>⇒ 중요 포인트는 알고리즘의 실행시간은 n에 정비례한다는 점

<br>

이를 빅오 표기법을 통해 적용시키면 알고리즘이 O(n)의 시간 복잡도를 갖는다 말한다.

많이 사용되는 빅오 표기법

| 빅오 표기법 | 1 | 4 | 8 | 32 |
| --- | --- | --- | --- | --- |
| O(1) | 1 | 1 | 1 | 1 |
| O(log n) | 0 | 2 | 3 | 5 |
| O(n) | 1 | 4 | 8 | 32 |
| O(n log n) | 2 | 8 | 24 | 160 |
| O(n^2) | 1 | 16 | 64 | 1024 |
| O(n^3) | 1 | 64 | 512 | 32786 |
| O(2^n) | 2 | 16 | 256 | 2^32 |
| O(n!) | 1 | 24 | 40326 | 26313*10^33 |

<br>

* * *

<br>

## 최선, 평균, 최악

동일한 알고리즘도 입력되는 데이터에 따라 다른 실행시간을 보일 수 있다.

- 예시
    - 정렬 알고리즘에 대해 정렬이 대부분 완료되어 있는 데이터를 입력한것이 정렬 되지 않은 데이터보다 빠르게 정렬이 완료된다.
    

그래서 알고리즘의 효율성은 입력되는 데이터 집합에 따라 3가지 경우로 나누어 평가할 수 있다.

- 최선의 경우 (Best Case) : 실행시간이 가장 적은 경우

<br>

- 평균적인 경우(Average Case) : 모든 입력을 고려하고 각 입력이 발생하는 확률을 고려한 평균 수행

<br>

- 최악의 경우(Worst Case) : 알고리즘 수행시간이 가장 오래 걸리는 경우

    >⇒ 평균적인 경우의 실행시간이 가장 좋아보이지만 광범위한 데이터 집합에 대한 알고리즘을 적용시켜 평균 값을 계산하는 것은 매우 어렵다.

    >⇒ 따라서 복잡도의 척도를 계산할 때는 최악의 경우를 주로 사용한다.

<br>

* * *

<br>

## 공간 복잡도

공간 복잡도란 프로그램을 실행시킨 후 완료하는 데 필요로 하는 자원 공간의 양을 말한다.

총 공간 요구 = 고정 공간 요구 + 가변 공간 요구 로 나타낼 수 있으며

S(P) = c + Sp(n) 으로 표기한다.

- 고정 공간 (알고리즘과 무관한 공간): 코드 저장 공간, 단순 변수 및 상수 (c)
- 가변 공간 (알고리즘 실행과 관련있는 공간): 실행 중 동적으로 필요한 공간 Sp(n)

    >⇒ 공간 복잡도 계산은 알고리즘 내에 필요한 공간 크기를 생각

<br>

예제)

```java
float abc(float a, float b, float c)

{
     return(a + b + b*c + (a + b - c)/(a + b) + 4.0);
}
```

공간 복잡도 구하기 위해 살펴볼것 a, b, c

>⇒ 함수 내에 abc 는 함수에서 해결하고자 하는 알고리즘과는 무관하다

>⇒ 공간 복잡도는 0

<br>

예제)

```java
float Sum(float a[], int n)
{
     float s = 0.0;

     for(int i = 1; i < = n; i++)
          s += a[i];
     return s;
 }
```

위의 프로그램에서 사용되는 변수 a[], n, s, i 이다. 

- a[] ,n
    - a[]는 합을 구하기 위해 반복문 내 참조 되고 있다.
    - n 또한 반복문에서 참조 되고 있음

>⇒ 총 사용된 크기는 (a[]를 저장하기 위한 공간) + 변수(n, s, i를 위한 공간)

>⇒ n + 3 이 된다

>⇒ O(n)
